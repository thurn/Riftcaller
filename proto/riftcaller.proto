// Copyright Â© Riftcaller 2021-present

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//    https://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package riftcaller;
option csharp_namespace = "Riftcaller.Protos";

import "google/protobuf/wrappers.proto";
import "google/protobuf/empty.proto";

// ============================================================================
// Masonry
// ============================================================================


enum FlexAlign {
    FLEX_ALIGN_UNSPECIFIED = 0;
    FLEX_ALIGN_AUTO = 1;
    FLEX_ALIGN_FLEX_START = 2;
    FLEX_ALIGN_CENTER = 3;
    FLEX_ALIGN_FLEX_END = 4;
    FLEX_ALIGN_STRETCH = 5;
}

enum FlexDisplayStyle {
    FLEX_DISPLAY_STYLE_UNSPECIFIED = 0;
    FLEX_DISPLAY_STYLE_FLEX = 1;
    FLEX_DISPLAY_STYLE_NONE = 2;
}

enum FlexDirection {
    FLEX_DIRECTION_UNSPECIFIED = 0;
    FLEX_DIRECTION_COLUMN = 1;
    FLEX_DIRECTION_COLUMN_REVERSE = 2;
    FLEX_DIRECTION_ROW = 3;
    FLEX_DIRECTION_ROW_REVERSE = 4;
}

enum FlexWrap {
    FLEX_WRAP_UNSPECIFIED = 0;
    FLEX_WRAP_NO_WRAP = 1;
    FLEX_WRAP_WRAP = 2;
    FLEX_WRAP_WRAP_REVERSE = 3;
}

enum FlexJustify {
    FLEX_JUSTIFY_UNSPECIFIED = 0;
    FLEX_JUSTIFY_FLEX_START = 1;
    FLEX_JUSTIFY_CENTER = 2;
    FLEX_JUSTIFY_FLEX_END = 3;
    FLEX_JUSTIFY_SPACE_BETWEEN = 4;
    FLEX_JUSTIFY_SPACE_AROUND = 5;
}

enum FlexOverflow {
    FLEX_OVERFLOW_UNSPECIFIED = 0;
    FLEX_OVERFLOW_VISIBLE = 1;
    FLEX_OVERFLOW_HIDDEN = 2;
}

enum FlexPosition {
    FLEX_POSITION_UNSPECIFIED = 0;
    FLEX_POSITION_RELATIVE = 1;
    FLEX_POSITION_ABSOLUTE = 2;
}

enum TextOverflow {
    TEXT_OVERFLOW_UNSPECIFIED = 0;
    TEXT_OVERFLOW_CLIP = 1;
    TEXT_OVERFLOW_ELLIPSIS = 2;
}

enum EasingMode {
    EASING_MODE_UNSPECIFIED = 0;
    EASING_MODE_EASE = 1;
    EASING_MODE_EASE_IN = 2;
    EASING_MODE_EASE_OUT = 3;
    EASING_MODE_EASE_IN_OUT = 4;
    EASING_MODE_LINEAR = 5;
    EASING_MODE_EASE_IN_SINE = 6;
    EASING_MODE_EASE_OUT_SINE = 7;
    EASING_MODE_EASE_IN_OUT_SINE = 8;
    EASING_MODE_EASE_IN_CUBIC = 9;
    EASING_MODE_EASE_OUT_CUBIC = 10;
    EASING_MODE_EASE_IN_OUT_CUBIC = 11;
    EASING_MODE_EASE_IN_CIRC = 12;
    EASING_MODE_EASE_OUT_CIRC = 13;
    EASING_MODE_EASE_IN_OUT_CIRC = 14;
    EASING_MODE_EASE_IN_ELASTIC = 15;
    EASING_MODE_EASE_OUT_ELASTIC = 16;
    EASING_MODE_EASE_IN_OUT_ELASTIC = 17;
    EASING_MODE_EASE_IN_BACK = 18;
    EASING_MODE_EASE_OUT_BACK = 19;
    EASING_MODE_EASE_IN_OUT_BACK = 20;
    EASING_MODE_EASE_IN_BOUNCE = 21;
    EASING_MODE_EASE_OUT_BOUNCE = 22;
    EASING_MODE_EASE_IN_OUT_BOUNCE = 23;
}

enum ImageScaleMode {
    IMAGE_SCALE_MODE_UNSPECIFIED = 0;
    IMAGE_SCALE_MODE_STRETCH_TO_FILL = 1;
    IMAGE_SCALE_MODE_SCALE_AND_CROP = 2;
    IMAGE_SCALE_MODE_SCALE_TO_FIT = 3;
}

enum FontStyle {
    FONT_STYLE_UNSPECIFIED = 0;
    FONT_STYLE_NORMAL = 1;
    FONT_STYLE_BOLD = 2;
    FONT_STYLE_ITALIC = 3;
    FONT_STYLE_BOLD_AND_ITALIC = 4;
}

enum OverflowClipBox {
    OVERFLOW_CLIP_BOX_UNSPECIFIED = 0;
    OVERFLOW_CLIP_BOX_PADDING_BOX = 1;
    OVERFLOW_CLIP_BOX_CONTENT_BOX = 2;
}

enum TextAlign {
    TEXT_ALIGN_UNSPECIFIED = 0;
    TEXT_ALIGN_UPPER_LEFT = 1;
    TEXT_ALIGN_UPPER_CENTER = 2;
    TEXT_ALIGN_UPPER_RIGHT = 3;
    TEXT_ALIGN_MIDDLE_LEFT = 4;
    TEXT_ALIGN_MIDDLE_CENTER = 5;
    TEXT_ALIGN_MIDDLE_RIGHT = 6;
    TEXT_ALIGN_LOWER_LEFT = 7;
    TEXT_ALIGN_LOWER_CENTER = 8;
    TEXT_ALIGN_LOWER_RIGHT = 9;
}

enum TextOverflowPosition {
    TEXT_OVERFLOW_POSITION_UNSPECIFIED = 0;
    TEXT_OVERFLOW_POSITION_END = 1;
    TEXT_OVERFLOW_POSITION_START = 2;
    TEXT_OVERFLOW_POSITION_MIDDLE = 3;
}

enum FlexVisibility {
    FLEX_VISIBILITY_UNSPECIFIED = 0;
    FLEX_VISIBILITY_VISIBLE = 1;
    FLEX_VISIBILITY_HIDDEN = 2;
}

enum WhiteSpace {
    WHITE_SPACE_UNSPECIFIED = 0;
    WHITE_SPACE_NORMAL = 1;
    WHITE_SPACE_NO_WRAP = 2;
}

message FlexColor {
    // Red color component, specified in the range 0.0 to 1.0 inclusive.
    float red = 1;

    // Green color component, specified in the range 0.0 to 1.0 inclusive.
    float green = 2;

    // Blue color component, specified in the range 0.0 to 1.0 inclusive.
    float blue = 3;

    // Alpha color component, specified in the range 0.0 (transparent) to 1.0
    // (opaque) inclusive.
    float alpha = 4;
}

message SpriteAddress {
    string address = 1;
}

message RenderTextureAddress {
    string address = 1;
}

message NodeBackground {
    oneof background_address {
        SpriteAddress sprite = 1;
        RenderTextureAddress render_texture = 2;
        StudioDisplay studio_display = 3;
    }
}

message FontAddress {
    string address = 1;
}

message ProjectileAddress {
    string address = 1;
}

message EffectAddress {
    string address = 1;
}

message AudioClipAddress {
    string address = 1;
}

// Identifies a set of customizations to animated character appearance
message CharacterPresetAddress {
    string address = 1;
}

message FlexVector2 {
    float x = 1;
    float y = 2;
}

message FlexVector3 {
    float x = 1;
    float y = 2;
    float z = 3;
}

enum DimensionUnit {
    DIMENSION_UNIT_UNSPECIFIED = 0;
    // Measurement in Pixels.
    // This is Unity density-independent pixels, not real physical pixels.
    DIMENSION_UNIT_PIXELS = 1;
    // Percentage of parent container
    DIMENSION_UNIT_PERCENTAGE = 2;
    // Units relative to 1% of the screen width
    DIMENSION_UNIT_VIEWPORT_WIDTH = 3;
    // Units relative to 1% of the screen height
    DIMENSION_UNIT_VIEWPORT_HEIGHT = 4;
    // Units relative to 100% of the size of the safe area top inset
    DIMENSION_UNIT_SAFE_AREA_TOP = 5;
    // Units relative to 100% of the size of the safe area right inset
    DIMENSION_UNIT_SAFE_AREA_RIGHT = 6;
    // Units relative to 100% of the size of the safe area bottom inset
    DIMENSION_UNIT_SAFE_AREA_BOTTOM = 7;
    // Units relative to 100% of the size of the safe area left inset
    DIMENSION_UNIT_SAFE_AREA_LEFT = 8;
}

message Dimension {
    DimensionUnit unit = 1;
    float value = 2;
}

message DimensionGroup {
    Dimension top = 1;
    Dimension right = 2;
    Dimension bottom = 3;
    Dimension left = 4;
}

message BorderWidth {
    float top = 1;
    float right = 2;
    float bottom = 3;
    float left = 4;
}

message BorderColor {
    FlexColor top = 1;
    FlexColor right = 2;
    FlexColor bottom = 3;
    FlexColor left = 4;
}

message BorderRadius {
    Dimension top_left = 1;
    Dimension top_right = 2;
    Dimension bottom_right = 3;
    Dimension bottom_left = 4;
}

message FlexRotate {
    float degrees = 1;
}

message FlexTranslate {
    Dimension x = 1;
    Dimension y = 2;
    float z = 3;
}

message FlexScale {
    FlexVector3 amount = 1;
}

message TextShadow {
    FlexVector2 offset = 1;
    float blur_radius = 2;
    FlexColor color = 3;
}

message TimeValue {
    uint32 milliseconds = 1;
}

message ImageSlice {
    uint32 top = 1;
    uint32 right = 2;
    uint32 bottom = 3;
    uint32 left = 4;
}

// Controls whether elements respond to interface events.
enum FlexPickingMode {
    // Unspecified, currently identical to 'position'.
    FLEX_PICKING_MODE_UNSPECIFIED = 0;
    // Picking enabled, events will be recognized.
    FLEX_PICKING_MODE_POSITION = 1;
    // Picking disabled, events ignored.
    FLEX_PICKING_MODE_IGNORE = 2;
}

// Allows the size of a Node to be determined by the size of its background
// sprite.
enum BackgroundImageAutoSize {
    BACKGROUND_IMAGE_AUTO_SIZE_UNSPECIFIED = 0;

    // Determine the Node height based on its specified width
    BACKGROUND_IMAGE_AUTO_SIZE_FROM_WIDTH = 1;

    // Determine the Node width based on its specified height
    BACKGROUND_IMAGE_AUTO_SIZE_FROM_HEIGHT = 2;
}

message FlexStyle {
    FlexAlign align_content = 1;
    FlexAlign align_items = 2;
    FlexAlign align_self = 3;
    FlexColor background_color = 4;
    NodeBackground background_image = 5;
    BorderColor border_color = 6;
    BorderRadius border_radius = 7;
    BorderWidth border_width = 8;
    DimensionGroup inset = 9;
    FlexColor color = 10;
    FlexDisplayStyle display = 11;
    Dimension flex_basis = 12;
    FlexDirection flex_direction = 13;
    google.protobuf.FloatValue flex_grow = 14;
    google.protobuf.FloatValue flex_shrink = 15;
    FlexWrap wrap = 16;
    Dimension font_size = 17;
    Dimension height = 18;
    FlexJustify justify_content = 19;
    Dimension letter_spacing = 20;
    DimensionGroup margin = 21;
    Dimension max_height = 22;
    Dimension max_width = 23;
    Dimension min_height = 24;
    Dimension min_width = 25;
    google.protobuf.FloatValue opacity = 26;
    FlexOverflow overflow = 27;
    DimensionGroup padding = 28;
    FlexPosition position = 29;
    FlexRotate rotate = 30;
    FlexScale scale = 31;
    TextOverflow text_overflow = 32;
    TextShadow text_shadow = 33;
    FlexTranslate transform_origin = 34;
    repeated TimeValue transition_delays = 35;
    repeated TimeValue transition_durations = 36;
    repeated string transition_properties = 37;
    repeated EasingMode transition_easing_modes = 38;
    FlexTranslate translate = 39;
    FlexColor background_image_tint_color = 40;
    ImageScaleMode background_image_scale_mode = 41;
    FontAddress font = 42;
    FontStyle font_style = 43;
    OverflowClipBox overflow_clip_box = 44;
    Dimension paragraph_spacing = 45;
    ImageSlice image_slice = 46;
    TextAlign text_align = 47;
    FlexColor text_outline_color = 48;
    google.protobuf.FloatValue text_outline_width = 49;
    TextOverflowPosition text_overflow_position = 50;
    FlexVisibility visibility = 51;
    WhiteSpace white_space = 52;
    Dimension width = 53;
    Dimension word_spacing = 54;
    FlexPickingMode picking_mode = 55;
    BackgroundImageAutoSize background_image_auto_size = 56;
}

message Flexbox {
}

message Text {
    string label = 1;
}

message ScrollBar {
    FlexStyle style = 1;
}

enum ScrollBarVisibility {
    SCROLL_BAR_VISIBILITY_UNSPECIFIED = 0;

    // Displays a scroll bar only if the content does not fit in the scroll
    // view. Otherwise, hides the scroll bar.
    SCROLL_BAR_VISIBILITY_AUTO = 1;

    // The scroll bar is always visible.
    SCROLL_BAR_VISIBILITY_ALWAYS_VISIBLE = 2;

    // The scroll bar is always hidden.
    SCROLL_BAR_VISIBILITY_HIDDEN = 3;
}

enum TouchScrollBehavior {
    TOUCH_SCROLL_BEHAVIOR_UNSPECIFIED = 0;

    // The content position can move past the ScrollView boundaries.
    TOUCH_SCROLL_BEHAVIOR_UNRESTRICTED = 1;

    // The content position can overshoot the ScrollView boundaries, but
    // then "snaps" back within them.
    TOUCH_SCROLL_BEHAVIOR_ELASTIC = 2;

    // The content position is clamped to the ScrollView boundaries.
    TOUCH_SCROLL_BEHAVIOR_CLAMPED = 3;
}

message ScrollViewNode {
    // The amount of elasticity to use when a user tries to scroll past
    // the boundaries of the scroll view.
    google.protobuf.FloatValue elasticity = 1;

    // Controls the scrolling speed of the horizontal scrollbar.
    google.protobuf.FloatValue horizontal_page_size = 2;

    // Horizontal scrollbar
    ScrollBar horizontal_scroll_bar = 3;

    // Specifies whether the horizontal scroll bar is visible.
    ScrollBarVisibility horizontal_scroll_bar_visibility = 4;

    // Controls the rate at which the scrolling movement slows after a user
    // scrolls using a touch interaction.
    google.protobuf.FloatValue scroll_deceleration_rate = 5;

    // The behavior to use when a user tries to scroll past the boundaries of
    // the ScrollView content using a touch interaction.
    TouchScrollBehavior touch_scroll_behavior = 6;

    // Controls the scrolling speed of the vertical scrollbar.
    google.protobuf.FloatValue vertical_page_size = 7;

    // Vertical scrollbar
    ScrollBar vertical_scroll_bar = 8;

    // Specifies whether the vertical scroll bar is visible.
    ScrollBarVisibility vertical_scroll_bar_visibility = 9;
}

message DraggableNode {
    // Identifiers of DropTargetNodes that are valid drop targets for this
    // draggable.
    repeated string drop_target_identifiers = 1;

    // Node to change the drag indicator to when this draggable is over a
    // valid target.
    Node over_target_indicator = 2;

    // Action to invoke when the node is dropped over a target.
    ClientAction on_drop = 3;

    // User must drag the element through this horizontal distance in screen
    // pixels before the UI responds. Useful to enable horizontal element
    // dragging from a vertical scroll view.
    google.protobuf.UInt32Value horizontal_drag_start_distance = 4;

    // If true, the original element is removed as part of this drag operation,
    // causing it to visually appear as though the user is moving it instead of
    // a placeholder.
    bool remove_original = 5;

    // Identifiers of children of this Draggable which should be hidden in the
    // drag indicator element.
    repeated string hide_indicator_children = 6;

    // Optionally, a UI element to use for the drag indicator instead of cloning
    // this element directly.
    Node custom_drag_indicator = 7;

    // Action to invoke when a gesture has been confirmed as a drag, i.e. the
    // element has been dragged through some fixed distance.
    ClientAction on_drag_detected = 8;
}

message DropTargetNode {
}

message TextFieldNode {
    // Globally unique identifier for this text field, used to avoid overwriting
    // user input. Cannot be the empty string.
    //
    // An initial value will only be set once on the TextField for a given
    // identifier.
    string global_identifier = 1;

    // Text to initially display within the text field.
    string initial_text = 2;

    // Allow multiple lines of input text
    bool multiline = 3;

    // Whether the text can be edited
    bool is_read_only = 4;

    // Maximum number of characters for the field.
    uint32 max_length = 5;

    // Set to true if the field is used to edit a password.
    bool is_password_field = 6;

    // Controls whether double clicking selects the word under the mouse
    // pointer or not.
    bool double_click_selects_word = 7;

    // Controls whether triple clicking selects the entire line under the
    // mouse pointer or not.
    bool triple_click_selects_line = 8;

    // The character used for masking in a password field.
    string mask_character = 9;
}

enum SliderDirection {
    SLIDER_DIRECTION_UNSPECIFIED = 0;

    SLIDER_DIRECTION_HORIZONTAL = 1;

    SLIDER_DIRECTION_VERTICAL = 2;
}

message SliderNode {
    // Value to display in the slider when first rendered.
    float initial_value = 1;

    // Label to display on this slider
    string label = 2;

    // If provided, the value of this slider will be read from and written
    // to the float PlayerPreference with the provided key.
    string preference_key = 3;

    /// Orientation of the slider. Defaults to horizontal.
    SliderDirection direction = 4;

    // The maximum value that the slider encodes.
    float high_value = 5;

    // This is the minimum value that the slider encodes.
    float low_value = 6;

    // This indicates whether or not this slider is inverted. For an inverted
    // horizontal slider, high value is located to the left, low value is
    // located to the right For an inverted vertical slider, high value is
    // located to the bottom, low value is located to the top.
    bool inverted = 7;

    // Size used to increment or decrement the value when clicking within
    // the slider.
    float page_size = 8;

    // The visibility of the optional field inside the slider control.
    bool show_input_field = 9;

    FlexStyle label_style = 10;

    FlexStyle drag_container_style = 11;

    FlexStyle tracker_style = 12;

    FlexStyle dragger_style = 13;

    FlexStyle dragger_border_style = 14;
}

message NodeType {
    oneof node_type {
        Text text = 1;
        ScrollViewNode scroll_view_node = 2;
        DraggableNode draggable_node = 3;
        DropTargetNode drop_target_node = 4;
        TextFieldNode text_field_node = 5;
        SliderNode slider_node = 6;

        // When adding new nodes here, update the
        // Reconciler.cs#HasInternalChildren() method to detect Unity child
        // views.
    }
}

message EventHandlers {
    ClientAction on_click = 1;

    ClientAction on_long_press = 2;

    ClientAction on_mouse_enter = 3;

    ClientAction on_mouse_leave = 4;

    ClientAction on_mouse_down = 5;

    ClientAction on_mouse_up = 6;

    ClientAction on_field_changed = 7;
}

// An element in the UI hierarchy of a given NodeType.
message Node {
    // Used to identify this node in the view hierarchy
    string name = 1;

    NodeType node_type = 2;

    repeated Node children = 3;

    EventHandlers event_handlers = 4;

    FlexStyle style = 5;
    FlexStyle hover_style = 6;
    FlexStyle pressed_style = 7;
    FlexStyle on_attach_style = 8;
}


// ============================================================================
// Game Primitives
// ============================================================================

message PlayerIdentifier {
    string ulid = 1;
}

enum PlayerSide {
    PLAYER_SIDE_UNSPECIFIED = 0;
    PLAYER_SIDE_COVENANT = 1;
    PLAYER_SIDE_RIFTCALLER = 2;
}

enum PlayerName {
    PLAYER_NAME_UNSPECIFIED = 0;
    PLAYER_NAME_USER = 1;
    PLAYER_NAME_OPPONENT = 2;
}

message CardIdentifier {
    PlayerSide side = 1;
    uint32 index = 2;

    // Optionally, identifies a specific ability within a logical card which
    // is represented by this displayed card.
    google.protobuf.UInt32Value ability_id = 3;

    // Optionally, identifies a special game action which this identifier
    // corresponds to. Identifiers are opaque to the client and should be
    // included with the 'play card' request.
    google.protobuf.UInt32Value game_action = 4;
}

message GameObjectIdentifier {
    oneof id {
        CardIdentifier card_id = 1;
        PlayerName character = 2;
        PlayerName deck = 3;
        PlayerName discard_pile = 4;
    }
}

enum RoomIdentifier {
    ROOM_IDENTIFIER_UNSPECIFIED = 0;
    ROOM_IDENTIFIER_VAULT = 1;
    ROOM_IDENTIFIER_SANCTUM = 2;
    ROOM_IDENTIFIER_CRYPT = 3;
    ROOM_IDENTIFIER_ROOM_A = 4;
    ROOM_IDENTIFIER_ROOM_B = 5;
    ROOM_IDENTIFIER_ROOM_C = 6;
    ROOM_IDENTIFIER_ROOM_D = 7;
    ROOM_IDENTIFIER_ROOM_E = 8;
}


// ============================================================================
// Game View
// ============================================================================


message CardIcon {
    // Background for the icon.
    SpriteAddress background = 1;
    // Text to display on the icon.
    google.protobuf.StringValue text = 2;
    // Scale multiplier for the background image.
    google.protobuf.FloatValue background_scale = 3;
}

message CardIcons {
    CardIcon top_left_icon = 1;
    CardIcon top_right_icon = 2;
    CardIcon bottom_right_icon = 3;
    CardIcon bottom_left_icon = 4;
    CardIcon arena_icon = 5;
}

message CardTitle {
    string text = 1;

    FlexColor text_color = 2;
}

message RulesText {
    string text = 1;
}

enum TargetingArrow {
    TARGETING_ARROW_UNSPECIFIED = 0;
    TARGETING_ARROW_RED = 1;
    TARGETING_ARROW_BLUE = 2;
    TARGETING_ARROW_GREEN = 3;
}

// Card has no targeting requirement
message NoTargeting {
    // True if this card can currently be played
    bool can_play = 1;
}

// This card should prompt for a room to be played into.
message PlayInRoom {
    // The card can be played if at least one identifier is present here
    repeated RoomIdentifier valid_rooms = 1;
}

// The card should show an arrow to select a room to target
message ArrowTargetRoom {
    // The card can be played if at least one identifier is present here
    repeated RoomIdentifier valid_rooms = 1;

    // Which arrow to show
    TargetingArrow arrow = 2;
}

message CardTargeting {
    oneof targeting {
        NoTargeting no_targeting = 1;
        PlayInRoom play_in_room = 2;
        ArrowTargetRoom arrow_target_room = 3;
    }
}

message ObjectPositionOffscreen {
}

enum ClientRoomLocation {
    CLIENT_ROOM_LOCATION_UNSPECIFIED = 0;
    CLIENT_ROOM_LOCATION_BACK = 1;
    CLIENT_ROOM_LOCATION_FRONT = 2;
}

message ObjectPositionRoom {
    RoomIdentifier room_id = 1;
    ClientRoomLocation room_location = 2;
}

enum ClientItemLocation {
    CLIENT_ITEM_LOCATION_UNSPECIFIED = 0;
    CLIENT_ITEM_LOCATION_LEFT = 1;
    CLIENT_ITEM_LOCATION_RIGHT = 2;
}

message ObjectPositionItem {
    ClientItemLocation item_location = 1;
}

message ObjectPositionStaging {
}

message ObjectPositionHand {
    PlayerName owner = 1;
}

message ObjectPositionDeck {
    PlayerName owner = 1;
}

message ObjectPositionDeckContainer {
    PlayerName owner = 1;
}

message ObjectPositionDiscardPile {
    PlayerName owner = 1;
}

message ObjectPositionDiscardPileContainer {
    PlayerName owner = 1;
}

// Large display of cards *while* the score animation is playing
message ObjectPositionScoreAnimation {
}

message ObjectPositionRaid {
}

message ObjectPositionBrowser {
}

message ObjectPositionCharacter {
    PlayerName owner = 1;
}

message ObjectPositionCharacterContainer {
    PlayerName owner = 1;
}

message ObjectPositionRewardChest {
}

/// An object position which represents moving into a given card.
message ObjectPositionIntoCard {
    CardIdentifier card_id = 1;
}

/// An object position which represents being stacked behind another card
message ObjectPositionStackedBehindCard {
    CardIdentifier card_id = 1;
}

enum RevealedCardsBrowserSize {
    REVEALED_CARDS_BROWSER_SIZE_UNSPECIFIED = 0;
    REVEALED_CARDS_BROWSER_SIZE_SMALL = 1;
    REVEALED_CARDS_BROWSER_SIZE_LARGE = 2;
}

/// An object position for newly-revealed cards, appears above other content
/// like the staging area.
message ObjectPositionRevealedCards {
    RevealedCardsBrowserSize size = 1;
}

/// Position in which active riftcallers are displayed during gameplay
message ObjectPositionRiftcallers {
    PlayerName owner = 1;
}

// Position to which cards are dragged during the card browser drag flow (e.g.
// when discarding to hand size).
message ObjectPositionBrowserDragTarget {
}

// Position in which cards are shown when one card is being selected out of
// a group of cards.
message ObjectPositionCardChoiceBrowser {
}

// Position in which cards in the hand are moved when some other option is being
// shown in the primary hand location (e.g. the Play Card browser).
message ObjectPositionHandStorage {
}

message ObjectPosition {
    // A key by which to sort this object -- objects with higher sorting keys
    // should be displayed 'on top of' or 'in front of' objects with lower
    // sorting keys.
    //
    // NOTE: Despite the fact that Unity uses the 'int' type for this in C#,
    // they actually store these as 16-bit signed integers, and your code
    // silently breaks if you use a number over 32,767!
    uint32 sorting_key = 1;

    // An additional key, can be used to break ties in `sorting_key`
    uint32 sorting_subkey = 2;

    oneof position {
        ObjectPositionOffscreen offscreen = 3;
        ObjectPositionRoom room = 4;
        ObjectPositionItem item = 5;
        ObjectPositionStaging staging = 6;
        ObjectPositionHand hand = 7;
        ObjectPositionDeck deck = 8;
        ObjectPositionDeckContainer deck_container = 9;
        ObjectPositionDiscardPile discard_pile = 10;
        ObjectPositionDiscardPileContainer discard_pile_container = 11;
        ObjectPositionRaid raid = 12;
        ObjectPositionBrowser browser = 13;
        ObjectPositionCharacter character = 14;
        ObjectPositionCharacterContainer character_container = 15;
        ObjectPositionRevealedCards revealed = 16;
        ObjectPositionRiftcallers riftcaller = 17;
        ObjectPositionBrowserDragTarget browser_drag_target = 18;
        ObjectPositionCardChoiceBrowser card_choice_browser = 19;
        ObjectPositionHandStorage hand_storage = 20;

        // Keep these at the end so they appear after their parents in sorted order
        ObjectPositionIntoCard into_card = 21;
        ObjectPositionStackedBehindCard stacked_behind_card = 22;
    }
}

// Object to highlight on info zoom
message InfoZoomHighlight {
    oneof highlight {
        CardIdentifier card = 1;
        RoomIdentifier room = 2;
    }
}

// Target for this card to be moved to. If provided, the user will be able
// to drag the card in the interface and it will animate to this position
// when released and send a MoveCardAction. This is distinct from *playing*
// a card and is used for operations like discarding from hand.
//
// Playing the card is disabled in this case.
message CardMoveTarget {
    // Position to move the card to when it is dragged
    ObjectPosition target_position = 1;
    // If true, the card can be reordered within the target_position. Used to
    // e.g. pick the order of cards on top of the deck.
    bool can_reorder = 2;
}

message RevealedCardView {
    SpriteAddress card_frame = 1;
    SpriteAddress title_background = 2;
    SpriteAddress jewel = 3;
    SpriteAddress image = 4;
    CardTitle title = 5;
    RulesText rules_text = 6;

    // Custom targeting behavior for a card. If unspecified, no targeting UI
    // is shown.
    CardTargeting targeting = 7;

    // Where to move a played card. Information from 'targeting' will be
    // incorporated to fill this in, e.g. if a room is targeted and
    // ObjectPositionRoom is selected here with no RoomId, the targeted room
    // is used.
    ObjectPosition on_release_position = 8;

    // Additional interface element rendered to the side of the card during an
    // info zoom.
    Node supplemental_info = 9;

    // Content to display behind the main image
    SpriteAddress image_background = 10;

    // Allows the card to be dragged in the UI for some effect. See CardMoveTarget
    // for more information.
    CardMoveTarget card_move_target = 11;

    // If provided, identifies a parent card for this card. An arrow will be
    // rendered from this card to its parent while it is being dragged,
    // indicating the relationship between these two cards.
    CardIdentifier point_to_parent = 12;

    // An object to highlight when the info zoom (hover/long press information
    // about this card) is being displayed. Typically used to indicate the
    // result of a choice, such as a card target.
    InfoZoomHighlight info_zoom_highlight = 13;
}

enum CardPrefab {
    CARD_PREFAB_UNSPECIFIED = 0;
    CARD_PREFAB_STANDARD = 1;
    CARD_PREFAB_TOKEN_CARD = 2;
    CARD_PREFAB_FULL_HEIGHT = 3;
    CARD_PREFAB_FULL_HEIGHT_TOKEN = 4;
}

// Custom VFX & SFX to apply to a card
message CardEffects {
    FlexColor outline_color = 1;

    // Continuous effect to display while this card is in an arena context
    EffectAddress arena_effect = 2;
}

message CardView {
    CardIdentifier card_id = 1;

    // Where is this card located in the game?
    ObjectPosition card_position = 2;

    // Which prefab to use for this card, controls the overall appearance
    CardPrefab prefab = 3;

    // Image shown as the back of this card
    SpriteAddress card_back = 4;

    // Whether the viewer (current player) is able to see the front of this card.
    bool revealed_to_viewer = 5;

    // Whether the card is in the 'face up' state in the arena. Has no effect
    // on cards which are not in play.
    bool is_face_up = 6;

    CardIcons card_icons = 7;

    // Frame shown on arena card when face-up
    SpriteAddress arena_frame = 8;

    // Frame shown on arena card when face-down
    SpriteAddress face_down_arena_frame = 9;

    // Used to e.g. determine which card back to display for this card.
    PlayerName owning_player = 10;

    // Card information which is only present on revealed cards.
    RevealedCardView revealed_card = 11;

    // Optionally, a position at which to create this card.
    //
    // If this card does not already exist, it will be created at this position
    // before being animated to its 'card_position'.
    ObjectPosition create_position = 12;

    // Optionally, a position at which to destroy this card.
    //
    // If provided, the card will be animated to this position before being
    // destroyed.
    ObjectPosition destroy_position = 13;

    /// Decorative VFX & SFX for this card.
    CardEffects effects = 14;
}

message PlayerInfo {
    // Rooms which this player can currently visit (raid/progress)
    repeated RoomIdentifier valid_rooms_to_visit = 1;

    // Configuration for appearance of character's avatar
    CharacterPresetAddress appearance = 2;
}

message ManaView {
    uint32 base_mana = 1;

    // Additional mana with custom use restrictions.
    uint32 bonus_mana = 2;

    // Can the viewer currently take the 'gain mana' action on this mana
    // display?
    bool can_take_gain_mana_action = 3;
}

message ScoreView {
    uint32 score = 1;
}

message ActionTrackerView {
    // Number of actions this player currently has available.
    uint32 available_action_count = 1;

    // Default number of actions this player gets for their turn.
    uint32 default_action_count = 2;
}

message DeckView {
    // How many cards are in this deck?
    uint32 card_count = 1;

    // Card back asset to use for this player's cards.
    SpriteAddress card_back = 2;

    // Can the viewer currently take the 'draw card' action on this deck?
    bool can_take_draw_card_action = 3;
}

message PlayerView {
    PlayerSide side = 1;
    PlayerInfo player_info = 2;
    ScoreView score = 3;
    ManaView mana = 4;
    ActionTrackerView action_tracker = 5;
    DeckView deck_view = 6;

    // Whether this player is currently able to take some game action
    bool can_take_action = 7;
}

enum GameCharacterFacingDirection {
    GAME_CHARACTER_FACING_DIRECTION_UNSPECIFIED = 0;
    GAME_CHARACTER_FACING_DIRECTION_UP = 1;
    GAME_CHARACTER_FACING_DIRECTION_DOWN = 2;
    GAME_CHARACTER_FACING_DIRECTION_LEFT = 3;
    GAME_CHARACTER_FACING_DIRECTION_RIGHT = 4;
}

// Positions of non-Card game objects.
message GameObjectPositions {
    ObjectPosition user_deck = 1;
    ObjectPosition opponent_deck = 2;
    ObjectPosition user_character = 3;
    ObjectPosition opponent_character = 4;
    GameCharacterFacingDirection user_character_facing = 5;
    GameCharacterFacingDirection opponent_character_facing = 6;
    ObjectPosition user_discard = 7;
    ObjectPosition opponent_discard = 8;
}

enum ArrowBubbleCorner {
    ARROW_BUBBLE_CORNER_UNSPECIFIED = 0;

    ARROW_BUBBLE_CORNER_BOTTOM_LEFT = 1;

    ARROW_BUBBLE_CORNER_BOTTOM_RIGHT = 2;
}

// Where to display the arrow bubble
message ArrowBubbleAnchor {
    oneof bubble_anchor {
        // Arrow pointing to a player
        PlayerName player = 1;

        // Arrow pointing to a room
        RoomIdentifier room = 2;

        // Arrow pointing to a player's deck
        PlayerName player_deck = 3;

        // Arrow pointing to a player's mana
        PlayerName player_mana = 4;
    }
}

message ShowArrowBubble {
    // Text to show.
    string text = 1;

    // How long the user needs to be idle for before displaying this effect. If
    // not specified, will show immediately.
    TimeValue idle_timer = 2;

    // Time before the popup should be hidden automatically. If not specified,
    // will remain permanently.
    TimeValue hide_time = 3;

    // Background color. Defaults to white.
    FlexColor color = 4;

    // Size of displayed text in Unity font units. Defaults to 3.0.
    google.protobuf.FloatValue font_size = 5;

    // Color of text. Defaults to black.
    FlexColor font_color = 6;

    // Multiplier for size of arrow bubble. Defaults to 1.0.
    google.protobuf.FloatValue scale = 7;

    // Which corner should the arrow be shown on?
    ArrowBubbleCorner arrow_corner = 8;

    // Where to display the arrow bubble
    ArrowBubbleAnchor anchor = 9;
}

message ShowToast {
    // Content to show inside the toast
    Node node = 1;

    // How long the user needs to be idle for before displaying this effect. If
    // not specified, will show immediately.
    TimeValue idle_timer = 2;

    // Time before the popup should be hidden automatically. If not specified,
    // will remain permanently.
    TimeValue hide_time = 3;
}

// Displays a tutorial UI element to the user when the user is idle for a fixed
// time period.
//
// Taking any game action resets the timer, and the timer doesn't start while
// network requests are pending.
message TutorialEffect {
    oneof tutorial_effect_type {
        // Arrow bubble representing a tooltip or text spoken by a player
        // in the game
        ShowArrowBubble arrow_bubble = 1;

        // Pops up a message to provide help context for the user. Only one
        // toast can be displayed at a time.
        ShowToast show_toast = 2;
    }
}

message GameView {
    PlayerView user = 1;
    PlayerView opponent = 2;

    // Updated values for the cards in this game. Any cards which have changed
    // position should be moved to their new positions in parallel. Cards which
    // do not exist in this list must be destroyed.
    repeated CardView cards = 3;

    // Whether a raid is currently active. If true, the raid overlay will be
    // displayed, the raid music will be played, etc.
    bool raid_active = 4;

    // Positions of non-Card game objects.
    GameObjectPositions game_object_positions = 5;

    // Controls for game actions such as interface prompts
    InterfaceMainControls main_controls = 6;

    // Tutorial UI elements
    repeated TutorialEffect tutorial_effects = 7;
}

message StudioAppearEffect {
    // Time to wait before the animation. Defaults to 300ms.
    TimeValue delay = 1;

    oneof studio_appear {
        bool set_revealed = 2;
    }
}

message StudioDisplayCard {
    CardView card = 1;

    // Optionally, visual effects to animate when the card first appears
    // on-screen.
    repeated StudioAppearEffect appear_effects = 2;
}

// Content to display as the background of a Node via the StudioManager.
message StudioDisplay {
    oneof display {
        StudioDisplayCard card = 1;
    }
}


// ============================================================================
// Actions
// ============================================================================


message StandardAction {
    // Opaque payload to send to the server when invoked.
    bytes payload = 1;

    // Immediate optimistic mutations to state for this action.
    CommandList update = 2;

    // User interface fields to read values from.
    //
    // If this map is not empty, the client will look for fields in the UI with
    // names matching the keys of this map and set the contents of those fields
    // as the values of this map when sending the action payload to the server.
    //
    // Field names should be mapped to the empty string when the action is
    // returned from the server.
    map<string, string> request_fields = 3;
}

// Spend an action to gain 1 mana.
//
// Optimistic: Mana is added immediately.
message GainManaAction {
}

// Spend an action to draw a card.
//
// Optimistic: Face-down card animates to reveal area.
message DrawCardAction {
}


// Spend an action to progress a room.
//
// Optimistic: Room visit animation plays
message ProgressRoomAction {
    RoomIdentifier room_id = 1;
}

message CardTarget {
    oneof card_target {
        RoomIdentifier room_id = 1;
    }
}

// Spend an action to play a card from hand.
//
// Optimistic:
//   - Card animates to its 'on_release' position. If the RoomIdentifier is
//     unspecified for a room position, the targeted room is used.
message PlayCardAction {
    CardIdentifier card_id = 1;
    CardTarget target = 2;
}

// Spend an action to initiate a raid on one of the covenant's rooms
//
// Optimistic: Room visit animation plays
message InitiateRaidAction {
    RoomIdentifier room_id = 1;
}

// Fetch the contents of a given interface panel.
message FetchPanelAction {
    InterfacePanelAddress panel_address = 1;
}

// Spend an action point with no other effect, typically used for
// tests
message SpendActionPointAction {}

// Move a card to a new position. This is distinct from *playing* a card and is
// used for operations like discarding cards from hand.
//
// Optimistic:
//   - Card animates to its 'card_move_target' position.
message MoveCardAction {
    CardIdentifier card_id = 1;

    // Optionally, an index position within the target position to move the
    // card to. Only included if 'can_reorder' is true on the CardMoveTarget.
    google.protobuf.UInt32Value index = 2;
}

// Possible game actions taken by the user.
//
// Actions have an associated 'optimistic' behavior to display while waiting
// for a server response. The client should not send multiple actions at the
// same time -- interaction should be disabled while an action is pending.
message ClientAction {
    oneof action {
        StandardAction standard_action = 1;
        FetchPanelAction fetch_panel = 2;
        GainManaAction gain_mana = 3;
        DrawCardAction draw_card = 4;
        PlayCardAction play_card = 5;
        ProgressRoomAction progress_room = 6;
        InitiateRaidAction initiate_raid = 7;
        SpendActionPointAction spend_action_point = 8;
        MoveCardAction move_card = 9;
    }
}

// Client state values included with the server response which must be
// included with all subsequent GameRequests.
message ClientMetadata {
    google.protobuf.StringValue adventure_id = 2;
    google.protobuf.StringValue game_id = 1;
}

// Initiate a play session and download the current state for the
// provided player.
message ConnectRequest {
    // User making this request.
    PlayerIdentifier player_id = 1;
}

// Poll to see if any new updates have been posted for the provided player,
// e.g. due to asynchronous AI game actions.
message PollRequest {
    // User making this request.
    PlayerIdentifier player_id = 1;
}

message GameRequest {
    // Action to perform.
    ClientAction action = 1;

    // Identifies the user making this request. At some point I'm going to
    // figure out how to set up authentication, but currently we operate on
    // the honor system :)
    PlayerIdentifier player_id = 2;

    // Interface panels which were open at the time of the action, to be
    // updated.
    repeated InterfacePanelAddress open_panels = 3;

    // Values received from a previous server call.
    ClientMetadata metadata = 4;
}

// ============================================================================
// Commands
// ============================================================================

message DebugLogCommand {
    string message = 1;
}

// Wait before executing the next command in sequence.
message DelayCommand {
    TimeValue duration = 1;
}

// Identifies an InterfacePanel.
message InterfacePanelAddress {
    string debug_string = 1;

    bytes serialized = 2;
}

// A 'panel' is an independently addressable block of UI. The contents
// of each known panel are cached and can then be opened immediately
// by the client, without waiting for a server response.
message InterfacePanel {
    InterfacePanelAddress address = 1;
    Node node = 2;

    // Optionally, a global screen overlay which should be displayed while
    // this panel is open, replacing the global overlay provided via
    // RenderScreenOverlayCommand.
    Node screen_overlay = 3;
}

// Possible corners which can be anchored.
enum AnchorCorner {
    ANCHOR_CORNER_UNSPECIFIED = 0;
    ANCHOR_CORNER_TOP_LEFT = 1;
    ANCHOR_CORNER_TOP_RIGHT = 2;
    ANCHOR_CORNER_BOTTOM_LEFT = 3;
    ANCHOR_CORNER_BOTTOM_RIGHT = 4;
}

// Requests that a specific corner of a Node be anchored to a specific
// corner of a card.
message CardAnchor {
    AnchorCorner node_corner = 1;
    AnchorCorner card_corner = 2;
}

// Render an interface element attached to a specific card.
message CardAnchorNode {
    CardIdentifier card_id = 1;
    Node node = 2;

    // Used to set the absolute position inset of 'node' to match corners of
    // the identified card. Later anchors in this list overwrite earlier
    // anchors in the case of a conflict.
    repeated CardAnchor anchors = 3;
}

message InterfaceMainControls {
    // Main controls area
    Node node = 1;

    // Main controls full-screen overlay, used for displaying instructional
    // rules text to the player such as "you must discard to hand size".
    Node overlay = 2;

    // Controls for specific cards
    repeated CardAnchorNode card_anchor_nodes = 3;
}

// Updates the contents of one or more user interface panels
message UpdatePanelsCommand {
    // List of panels to update.
    repeated InterfacePanel panels = 1;
}

// Open a panel and display the provided loading state while it is
// being fetched
message AddressWithLoadingState {
    InterfacePanelAddress open_panel = 1;

    // Content to display if this panel is not already cached
    Node loading_state = 2;
}

// Options for transitioning to a new panel.
//
// Will log an error if 'open' is not available and no loading state is
// provided, or if the loading state is not available.
message PanelTransitionOptions {
    // New panel to open.
    InterfacePanelAddress open = 1;

    // Previous panel to close, if any
    InterfacePanelAddress close = 2;

    // Panel to display if 'open' is not present in the panel cache.
    InterfacePanelAddress loading = 3;

    // If true, displays a loading animation on the 'close' screen while
    // 'open' is not presenet in the panel cache.
    bool wait_to_load = 4;
}

// Requests to open or close the given interface panel.
message TogglePanelCommand {
    oneof toggle_command {
        // Open a new panel with transition options.
        PanelTransitionOptions transition = 1;

        // Opens a new bottom sheet with the indicated panel.
        //
        // Closes any existing bottom sheet.
        InterfacePanelAddress open_bottom_sheet_address = 2;

        // Closes the currently-open bottom sheet.
        google.protobuf.Empty close_bottom_sheet = 3;

        // Pushes the indicated panel as a new bottom sheet page.
        //
        // If no bottom sheet is currently open, the behavior is identical to
        // 'open_bottom_sheet'.
        InterfacePanelAddress push_bottom_sheet_address = 4;

        // Pops the currently visible bottom sheet page and displays the
        // indicated panel as the *new* sheet content.
        //
        // If no bottom sheet is currently open, the behavior is identical to
        // 'open_bottom_sheet'.
        InterfacePanelAddress pop_to_bottom_sheet_address = 5;
    }
}

// Updates the current GameView state.
message UpdateGameViewCommand {
    GameView game = 1;

    // Whether this update should be animated
    bool animate = 2;
}

enum RoomVisitType {
    ROOM_VISIT_TYPE_UNSPECIFIED = 0;
    ROOM_VISIT_TYPE_INITIATE_RAID = 1;
    ROOM_VISIT_TYPE_PROGRESS_ROOM = 2;
}

// Animates 'initiator' moving to a room and plays a standard particle effect
// based on the visit type.
message VisitRoomCommand {
    PlayerName initiator = 1;
    RoomIdentifier room_id = 2;
    RoomVisitType visit_type = 3;
}

enum CardCreationAnimation {
    CARD_CREATION_ANIMATION_UNSPECIFIED = 0;

    // Animates the card moving from the deck to the staging area.
    CARD_CREATION_ANIMATION_DRAW_CARD = 1;

    // Animates the card moving from its parent card (indicated by its card
    // identifier with no 'ability_id') to its create position.
    CARD_CREATION_ANIMATION_FROM_PARENT_CARD = 2;
}

// Creates a new token card.
//
// This command is typically used to create short-lived 'token' cards to
// represent things like abilities firing, but this isn't specifically required.
// If a matching CardIdentifier already exists, that card will be updated
// instead.
//
// Note that the created card will always be deleted by the next
// UpdateGameViewCommand if its ID is not present in that update.
message CreateTokenCardCommand {
    CardView card = 1;

    // Whether this update should be animated
    bool animate = 2;
}

// Adds a visual effect to a card which displays a trail while it is
// being moved. This is accomplished in practice by attaching a projectile
// body to the card itself. The effect is removed when the card finishes
// being moved to a new position.
message SetCardMovementEffectCommand {
    CardIdentifier card_id = 1;

    ProjectileAddress projectile = 2;
}

message GameObjectMove {
    GameObjectIdentifier id = 1;

    ObjectPosition position = 2;
}

// Move a list of game objects to new positions, in parallel
message MoveGameObjectsCommand {
    repeated GameObjectMove moves = 1;

    bool disable_animation = 2;

    // A delay once the cards reach their destination
    TimeValue delay = 3;
}

message PlaySoundCommand {
    AudioClipAddress sound = 1;
}

enum MusicState {
    MUSIC_STATE_UNSPECIFIED = 0;
    MUSIC_STATE_SILENT = 1;
    MUSIC_STATE_GAMEPLAY = 2;
    MUSIC_STATE_RAID = 3;
    MUSIC_STATE_MAIN_MENU = 4;
}

message SetMusicCommand {
    MusicState music_state = 1;
}

// Fire a projectile from one game object at another.
message FireProjectileCommand {
    GameObjectIdentifier source_id = 1;
    GameObjectIdentifier target_id = 2;

    // Projectile to fire from the 'source_id' card to 'target_id'
    ProjectileAddress projectile = 3;

    // How long the projectile should take to hit its target.
    TimeValue travel_duration = 4;

    AudioClipAddress fire_sound = 5;

    AudioClipAddress impact_sound = 6;

    // Additional effect to display on the target on hit.
    EffectAddress additional_hit = 7;

    // Delay before showing the additional hit. If provided, the original
    // projectile Hit effect will be hidden before showing the new hit effect.
    TimeValue additional_hit_delay = 8;

    // During to wait for the project's impact effect before continuing
    TimeValue wait_duration = 9;

    // If true, the target will be hidden after being hit during the
    // 'wait_duration' and before jumping to 'jump_to_position'.
    bool hide_on_hit = 10;

    // Position for the target to jump to after being hit.
    ObjectPosition jump_to_position = 11;
}

message PlayEffectPosition {
    oneof effect_position {
        GameObjectIdentifier game_object = 1;
    }
}

message PlayEffectCommand {
    EffectAddress effect = 1;

    PlayEffectPosition position = 2;

    google.protobuf.FloatValue scale = 3;

    // How long to wait before continuing.
    TimeValue duration = 4;

    AudioClipAddress sound = 5;

    // If true, the effect will render *behind* arena items
    bool arena_effect = 6;

    // Tint color to apply to all particle systems in this effect.
    FlexColor start_color = 7;

    // Optionally, an owner for this effect, used to identify effects later
    // for removal via 'ClearEffectsCommands'
    GameObjectIdentifier owner = 8;
}

enum GameMessageType {
    GAME_MESSAGE_TYPE_UNSPECIFIED = 0;
    GAME_MESSAGE_TYPE_DAWN = 1;
    GAME_MESSAGE_TYPE_DUSK = 2;
    GAME_MESSAGE_TYPE_VICTORY = 3;
    GAME_MESSAGE_TYPE_DEFEAT = 4;
}

message DisplayGameMessageCommand {
    GameMessageType message_type = 1;
}

// Used to hide and show all game UI elements.
message SetGameObjectsEnabledCommand {
    bool game_objects_enabled = 1;
}

message DisplayRewardsCommand {
    repeated CardView rewards = 1;
}

enum SceneLoadMode {
    SCENE_LOAD_MODE_UNSPECIFIED = 0;
    // Close all currently open scenes before loading.
    SCENE_LOAD_MODE_SINGLE = 1;
    // Adds a scene to the current loaded scenes.
    SCENE_LOAD_MODE_ADDITIVE = 2;
}

// Loads a named Unity scene
message LoadSceneCommand {
    string scene_name = 1;
    SceneLoadMode mode = 2;
    // If true, skip loading this scene if it matches the currently-loaded
    // main scene.
    bool skip_if_current = 3;
}

// Sets a client-side boolean player preference
message SetBooleanPreference {
    string key = 1;
    bool value = 2;
}

// Possible client logging levels
enum LogMessageLevel {
    LOG_MESSAGE_LEVEL_UNSPECIFIED = 0;
    LOG_MESSAGE_LEVEL_STANDARD = 1;
    LOG_MESSAGE_LEVEL_WARNING = 2;
    LOG_MESSAGE_LEVEL_ERROR = 3;
}

// Logs a client message
message LogMessage {
    string text = 1;
    LogMessageLevel level = 2;
}

// Activates client-side debugging functionality
message ClientDebugCommand {
    oneof debug_command {
        google.protobuf.Empty show_logs = 1;
        ClientAction invoke_action = 2;
        LogMessage log_message = 3;
        SetBooleanPreference set_boolean_preference = 4;
        google.protobuf.Empty show_feedback_form = 5;
    }
}

// Position of a tile on the world map
//
// We use offset hex coordinates with the "Pointy Top - Odd Rows Shifted
// Right" convention, with values increasing moving up and right.
//
// ```text
//
//       /  \    / \
//     /     \ /     \
//    |  0,2  |  1,2  |
//    |       |       |
//   / \     / \     / \
// /     \ /     \ /     \
//|  0,1  |  1,1  |  2,1  |
//|       |       |       |
// \     / \     / \     /
//   \ /     \ /     \ /
//    |  0,0  |  1,0  |
//    |       |       |
//     \     / \     /
//       \ /     \ /
//
// ```
message MapPosition {
    int32 x = 1;
    int32 y = 2;
}

enum MapTileType {
    MAP_TILE_TYPE_UNSPECIFIED = 0;

    // Player cannot move through this tile
    MAP_TILE_TYPE_OBSTACLE = 1;

    // Player can walk through this tile
    MAP_TILE_TYPE_WALKABLE = 2;

    // Player cannot enter this tile but can click to walk adjacent to it
    MAP_TILE_TYPE_VISITABLE = 3;
}

message WorldMapSprite {
    // Addressable asset path of sprite to display on the hex grid
    SpriteAddress sprite_address = 1;

    // Color tint for the provided sprite.
    FlexColor color = 2;

    // Controls the position of the tile image. Note that tiles by default are
    // anchored at (0,-0.64), meaning they're shifted to screen bottom.
    FlexVector3 anchor_offset = 3;

    // Scale transformation to apply to the image.
    FlexVector3 scale = 4;
}

// Represents a character displayed on the world map
message WorldMapCharacter {
    // Visual appearance of character
    CharacterPresetAddress appearance = 1;

    // Direction character is facing
    GameCharacterFacingDirection facing_direction = 2;
}

// Represents the contents of a world map tile.
message WorldMapTile {
    // Images to display on this tile. Will be rendered in z-index order, with
    // later sprites appearing on top of earlier ones. Sprites always display
    // below the player character layer.
    repeated WorldMapSprite sprites = 1;

    // Tile position.
    MapPosition position = 2;

    // Action to invoke when this tile is visited by the player.
    ClientAction on_visit = 3;

    // How can the player character navigate through this tile?
    MapTileType tile_type = 4;

    // A character to display on this tile
    WorldMapCharacter character = 5;
}

// Updates the world map tilemap. Only valid in the 'World' scene.
message UpdateWorldMapCommand {
    repeated WorldMapTile tiles = 1;
}

// Displays a UI element on top of all other elements. This is typically used
// to render chrome, e.g. buttons related to global navigation.
message RenderScreenOverlayCommand {
    Node node = 1;
}

// A method for uniquely identifying a single user interface element
message ElementSelector {
    oneof selector {
        // Identify an element by name
        string element_name = 1;

        // The element currently being dragged
        google.protobuf.Empty drag_indicator = 2;

        // A synthetic element created via an operation such as
        // 'CreateTargetAtChildIndex'.
        string target_element = 3;
    }
}

// Describes how to animate an element change
message ElementAnimation {
    // Duration over which to animate the change.
    TimeValue duration = 1;

    // Easing curve to use for the element animation.
    EasingMode ease = 2;
}

// Animates the element to match the position of another element
message AnimateToPosition {
    ElementSelector destination = 1;
    ElementAnimation animation = 2;

    // If false, the Y coordinate of the target positon is offset by 1/2
    // the source element's height.
    bool disable_height_half_offset = 3;

    // If false, the X coordinate of the target positon is offset by 1/2
    // the source element's width
    bool disable_width_half_offset = 4;
}

// Creates a cloned invisible 'target' element at a given child index position
// of a parent element. The target starts at 1x1 size and animates its width and
// height to match the size of the source element. After reaching full size, it
// becomes visible.
//
// The target can be retrieved via the 'target' element selector using the
// provided target_name. These element names only need to be unique among
// other targets, it is idiomatic to use the same name as the source element.
message CreateTargetAtChildIndex {
    ElementSelector parent = 1;
    uint32 index = 2;
    string target_name = 3;
    ElementAnimation animation = 4;
}

// Animates a style property of an element to a new value
message AnimateElementStyle {
    ElementAnimation animation = 1;

    oneof property {
        float opacity = 2;
        float width = 3;
        float height = 4;
        FlexVector2 scale = 5;
    }
}

// Possible updates to a single interface element
message InterfaceUpdate {
    oneof update {
        // Make a copy of this element and set the original to
        // 'visiblity: hidden'. Subsequent selectors in this sequence will
        // apply to the cloned element if they search for an element by name.
        google.protobuf.Empty clone_element = 1;

        // Destroys the element
        google.protobuf.Empty destroy_element = 2;

        // Animates the element to match the position of another element
        AnimateToPosition animate_to_position = 3;

        // Immediately apply a style to this element
        FlexStyle apply_style = 4;

        // Animates a change to this element's style
        AnimateElementStyle animate_style = 5;

        // Creates a 'target' child element to use for position animations
        // when adding something to a list
        CreateTargetAtChildIndex create_target_at_child_index = 6;
    }
}

// A single, optionally animated, tranformation to an interface element.
message UpdateInterfaceStep {
    // Identifies the element to update
    ElementSelector element = 1;

    // How to mutate the selected element
    InterfaceUpdate update = 2;

    // Delay to introduce before performing this mutation
    TimeValue start_time = 3;
}

// Applies a sequence of user interface element mutations
message UpdateInterfaceCommand {
    repeated UpdateInterfaceStep steps = 1;
}

// Boolean-valued expression
message ConditionalQuery {
    oneof query {
        // Does a given user interface element exist?
        ElementSelector element_exists = 1;
    }
}

// Conditionally executes one of two command lists based on a boolean query
message ConditionalCommand {
    // Boolean value to evaluate on the client
    ConditionalQuery query = 1;

    // Commands to run if 'query' is true
    CommandList if_true = 2;

    // Commands to run if 'query' is false
    CommandList if_false = 3;
}

// Displays an 'info zoom' relative to the current mouse or touch position,
// a popup when a card is selected which shows a larger version of it which
// is easier to read.
message InfoZoomCommand {
    // Whether to show or hide the InfoZoom.
    bool show = 1;

    // The card to display information about, if 'show' is true.
    CardView card = 2;
}

// A combination of keys which can trigger an action.
message KeyboardShortcut {
    string key_name = 1;
    bool alt = 2;
    bool ctrl = 3;
    bool shift = 4;
}

// A single keyboard shortcut and associated action.
message KeyboardMapping {
    KeyboardShortcut shortcut = 1;
    ClientAction action = 2;
}

// Provides a mapping from keyboard shortcuts to actions which should be available.
//
// Overwrites all previous mappings.
message SetKeyboardShortcutsCommand {
    repeated KeyboardMapping mapping_list = 1;
}

// Plays a temporary flip animation for a card. This should *usually* be handled by
// just changing the card's state, but in some cases we play the animation to help
// add clarity about what is happening even though the card is still revealed (for
// example, when a minion is unsummoned).
message TurnFaceDownArenaAnimationCommand {
    // Card to turn face down
    CardIdentifier card_id = 1;
}

// Remove all effects owned by a given game object, as specified by the
// 'owner' field on 'PlayEffectCommand'.
message ClearEffectsCommand {
    // Owner for effects to remove
    GameObjectIdentifier owner = 1;
}

message GameCommand {
    oneof command {
        ClientDebugCommand debug = 1;
        DelayCommand delay = 2;
        UpdatePanelsCommand update_panels = 3;
        TogglePanelCommand toggle_panel = 4;
        UpdateGameViewCommand update_game_view = 5;
        VisitRoomCommand visit_room = 6;
        PlaySoundCommand play_sound = 7;
        SetMusicCommand set_music = 8;
        FireProjectileCommand fire_projectile = 9;
        PlayEffectCommand play_effect = 10;
        DisplayGameMessageCommand display_game_message = 11;
        SetGameObjectsEnabledCommand set_game_objects_enabled = 12;
        DisplayRewardsCommand display_rewards = 13;
        LoadSceneCommand load_scene = 14;
        MoveGameObjectsCommand move_game_objects = 15;
        CreateTokenCardCommand create_token_card = 16;
        SetCardMovementEffectCommand set_card_movement_effect = 17;
        UpdateWorldMapCommand update_world_map = 18;
        RenderScreenOverlayCommand render_screen_overlay = 19;
        UpdateInterfaceCommand update_interface = 20;
        ConditionalCommand conditional = 21;
        InfoZoomCommand info_zoom = 22;
        SetKeyboardShortcutsCommand set_keyboard_shortcuts = 23;
        TurnFaceDownArenaAnimationCommand turn_face_down_arena_animation = 24;
        ClearEffectsCommand clear_persistent_effects = 25;
    }
}

// Metadata to include with logging for this client, e.g. for crash
// attribution. These values are indexed by key and are never removed,
// the server can clear an entry by explicitly sending the empty string.
message LoggingMetadata {
    string key = 1;
    string value = 2;
}

message CommandList {
    // Metadata to include with logging for this client, e.g. for crash
    // attribution.
    repeated LoggingMetadata logging_metadata = 1;

    repeated GameCommand commands = 2;

    // Optionally, client information to store. When provided, this
    // must be included on all subsequent PerformAction calls.
    ClientMetadata metadata = 3;
}

service Riftcaller {
    // Initiate a new server connection.
    rpc Connect(ConnectRequest) returns (stream CommandList);

    // Perform a game action.
    rpc PerformAction(GameRequest) returns (CommandList);
}
